Import stuff.

```{python}
import os
import random
import gdown
import numpy as np
import matplotlib.pyplot as plt
import torch
import torch.nn as nn
import torch.optim as optim
import torchvision
import torchvision.transforms as transforms
import torchvision.datasets as datasets
import torch.nn.functional as F
from torch.utils.data import DataLoader, random_split

import modules.models as models
```

Set device.

```{python}
if torch.backends.mps.is_available():
    device = torch.device('mps')
elif torch.cuda.is_available():
    device = torch.device('cuda')
else:
    device = torch.device('cpu')

torch.set_default_device(device)

print(device)
```

Load train and test iterable using datasets.CelebA.

```{python}
imsize = 128
batch_size = 500

loader = transforms.Compose([
    transforms.Resize([imsize, imsize]),
    transforms.Grayscale(1),
    transforms.ToTensor(),
    transforms.Normalize(0, 1)
])

dataset = datasets.CelebA(
    root = './data',
    split='all',
    target_type='attr',
    transform=loader,
    download=True
)

train_size = int(0.8*len(dataset))
test_size = len(dataset) - train_size

train_dataset, test_dataset = random_split(
    dataset,
    [train_size, test_size],
    generator=torch.Generator(device=device)
)

train_loader = DataLoader(
    train_dataset,
    batch_size=batch_size,
    shuffle=True,
    generator=torch.Generator(device=device)
)

test_loader = DataLoader(
    test_dataset,
    batch_size=batch_size,
    shuffle=True,
    generator=torch.Generator(device=device)
)

dataiter = iter(train_loader)
images, labels = next(dataiter)
```

Choose factor to predict.

```{python}
attributes = (
    '5_o_Clock_Shadow', 
    'Arched_Eyebrows', 
    'Attractive', 
    'Bags_Under_Eyes', 
    'Bald', 
    'Bangs', 
    'Big_Lips', 
    'Big_Nose', 
    'Black_Hair', 
    'Blond_Hair', 
    'Blurry', 
    'Brown_Hair', 
    'Bushy_Eyebrows', 
    'Chubby', 
    'Double_Chin', 
    'Eyeglasses', 
    'Goatee', 
    'Gray_Hair', 
    'Heavy_Makeup', 
    'High_Cheekbones', 
    'Male', 
    'Mouth_Slightly_Open', 
    'Mustache', 
    'Narrow_Eyes', 
    'No_Beard', 
    'Oval_Face', 
    'Pale_Skin', 
    'Pointy_Nose', 
    'Receding_Hairline', 
    'Rosy_Cheeks', 
    'Sideburns', 
    'Smiling', 
    'Straight_Hair', 
    'Wavy_Hair', 
    'Wearing_Earrings', 
    'Wearing_Hat', 
    'Wearing_Lipstick', 
    'Wearing_Necklace', 
    'Wearing_Necktie', 
    'Young'
)

factor = attributes.index('Male')
classes = ('Not ' + attributes[factor], attributes[factor])
```

Show random image with factors.

```{python}
# view image
unloader = transforms.ToPILImage()

plt.ion()

def imshow(tensor):
    image = tensor.cpu().clone()
    image = image.squeeze(0)
    image = unloader(image)
    plt.imshow(image)
    plt.pause(0.001)

plt.figure()

rand_num = random.randint(0, batch_size-1)

imshow(images[rand_num])
print('Selected factor:')
print(classes[labels[:, factor][rand_num]])
print('\nAll factors:')
for i, value in enumerate(labels[rand_num]):
    if value.item() == 1:
        print(attributes[i])
```

Set model and other stuff.

```{python}
torch.manual_seed(2687)
cnn = models.cnnModel3_128()
criterion = nn.CrossEntropyLoss()
optimizer = torch.optim.SGD(
    cnn.parameters(), 
    lr=0.1,
    momentum=0.9,
    weight_decay=0.001
)
scheduler = torch.optim.lr_scheduler.ReduceLROnPlateau(
    optimizer=optimizer,
    mode='min',
    factor=0.9
)

print(next(cnn.parameters()).device)
print(cnn)
```

Train for a specified number of epochs

```{python}
epochs = 6
train_losses = []
test_losses = []
train_correct = []
test_correct = []
for i in range(epochs):
    train_cr = 0
    test_cr = 0

    for j, (X_train, y_train) in enumerate(train_loader):
        j += 1
        X_train = X_train.to(device)
        y_train = y_train[:, factor]
        y_pred = cnn.forward(X_train)
        loss = criterion(y_pred, y_train)

        predicted = torch.max(y_pred.data, 1)[1]
        batch_cr = (predicted == y_train).sum()
        train_cr += batch_cr

        optimizer.zero_grad()
        loss.backward()
        optimizer.step()

        print(f'Epoch: {i+1} | Batch: {j}')
        print(f'Loss: {loss.item()} | Accuracy: {batch_cr/len(X_train)}')
    
    train_losses.append(loss.item())
    train_correct.append(train_cr.item())

    with torch.no_grad():
        for j, (X_test, y_test) in enumerate(test_loader):
            X_test = X_test.to(device)
            y_test = y_test[:, factor]
            y_val = cnn.forward(X_test)
            predicted = torch.max(y_val.data, 1)[1]
            test_cr += (predicted == y_test).sum()

    loss = criterion(y_val, y_test)
    scheduler.step(loss)
    test_losses.append(loss.item())
    test_correct.append(test_cr.item())
```

Graph loss at the end of each epoch.

```{python}
plt.plot(train_losses, label="Training Loss")
plt.plot(test_losses, label="Validation Loss")
plt.title("Loss at Epoch")
plt.legend()
```

Graph accuracy of each epoch.

```{python}
# graph the accuracy at the end of each epoch
plt.plot([t/train_size for t in train_correct], label="Training Accuracy")
plt.plot([t/test_size for t in test_correct], label="Validation Accuracy")
plt.title("Accuracy at the end of each Epoch")
plt.legend()
```

Save weights and biases.

```{python}
torch.save(cnn.state_dict(), 'trained_models/cnn3_128_v1.pth')
```

Load weights and biases into a new model object.

```{python}
test_cnn = models.cnnModel3_128()
test_cnn.load_state_dict(torch.load('trained_models/cnn3_128_v1.pt'))
```

Load and show external test images.

```{python}
external_test_dataset = datasets.ImageFolder(
    root='data/Validation/',
    transform=loader
)

external_test_loader = DataLoader(
    external_test_dataset,
    batch_size=len(external_test_dataset),
    shuffle=True,
    generator=torch.Generator(device=device)
)

dataiter = iter(external_test_loader)
images, labels = next(dataiter)

imshow(torchvision.utils.make_grid(images))

print(' '.join(f'{classes[labels[j]]:5s}' for j in range(len(external_test_dataset))))
```

Make predictions based on saved model.

```{python}
cnn_output = test_cnn.forward(images.to(device))
y_pred = torch.max(cnn_output, 1)[1]

for i in range(len(external_test_dataset)):
    imshow(images[i])

    print(f'Prediction: {classes[y_pred[i]]}')
    print(f'{classes[0]} weight: {cnn_output[i][0]}')
    print(f'{classes[1]} weight: {cnn_output[i][1]}')
```

Show number of correct and incorrect predictions.

```{python}
ext_correct = (y_pred == labels).sum().item()
ext_incorrect = (y_pred != labels).sum().item()
print(f'Correct predictions: {ext_correct}')
print(f'Incorrect predictions: {ext_incorrect}')
print(f'Accurary: {ext_correct/(ext_correct+ext_incorrect)}')
```

Show incorrect predictions.

```{python}
for i in range(len(external_test_dataset)):
    if y_pred[i] != labels[i]:
        imshow(images[i])
```