Import packages and stuff we'll need.

```{python}
import os
import torch
import torch.nn as nn
import torch.optim as optim
from PIL import Image
import matplotlib.pyplot as plt
import torchvision.transforms as transforms
import torch.nn.functional as F
import numpy as np
from sklearn.model_selection import train_test_split
```

Set device (M1/CUDA/CPU).

```{python}
if torch.backends.mps.is_available():
    device = torch.device('mps')
elif torch.cuda.is_available():
    device = torch.device('cuda')
else:
    device = torch.device('cpu')

torch.set_default_device(device)
```

Get image file directories.

```{python}
directory_male = 'data/ThisPersonDoesNotExist/Male/'

image_names_male = os.listdir(directory_male)
image_files_male = [os.path.join(directory_male, image_file_name) for image_file_name in image_names_male]

directory_female = 'data/ThisPersonDoesNotExist/Female/'

image_names_female = os.listdir(directory_female)
image_files_female = [os.path.join(directory_female, image_file_name) for image_file_name in image_names_female]
```

Import images and correct gender classification as tensors.

```{python}
imsize = 128

loader = transforms.Compose([
    transforms.Resize(imsize),
    transforms.ToTensor()
])

def image_loader(image_file):
    image = Image.open(image_file)
    image = loader(image).unsqueeze(0)
    return image.to(device, torch.float)

male_tensor = torch.empty((0, 3, imsize, imsize))
n_male = 0
for male in image_files_male[0:1000]:
    male_tensor = torch.cat(
        (male_tensor, image_loader(male))
    )
    n_male += 1
y_male = torch.full((n_male,), 0)

female_tensor = torch.empty((0, 3, imsize, imsize))
n_female = 0
for female in image_files_female[0:1000]:
    female_tensor = torch.cat(
        (female_tensor, image_loader(female))
    )
    n_female += 1
y_female = torch.full((n_female,), 1)

y = torch.cat((y_male, y_female))
X = torch.cat((male_tensor, female_tensor))
```

Convert a sample tensor back to image as verification.

```{python}
# view image
unloader = transforms.ToPILImage()

plt.ion()

def imshow(tensor):
    image = tensor.cpu().clone()
    image = image.squeeze(0)
    image = unloader(image)
    plt.imshow(image)
    plt.pause(0.001)

plt.figure()

imshow(female_tensor[10])
```

Define training and testing sets.

```{python}
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=2687)
```

Define multi-layer perceptron neural network class.

```{python}
class mlpModel(nn.Module):
    def __init__(self, in_features=3*imsize*imsize, h1=120*16, h2=84*16, out_features=2):
        super().__init__()
        self.fc1 = nn.Linear(in_features, h1)
        self.fc2 = nn.Linear(h1, h2)
        self.out = nn.Linear(h2, out_features)

    def forward(self, x):
        x = torch.flatten(x, 1)
        x = F.relu(self.fc1(x))
        x = F.relu(self.fc2(x))
        x = self.out(x)
        return x
```

Set model, loss measure, and optimiser parameters.

```{python}
torch.manual_seed(2687)
mlp = mlpModel()
criterion = nn.CrossEntropyLoss()
optimizer = torch.optim.Adam(mlp.parameters(), lr=0.001)
```

Train MLP model.

```{python}
epochs = 100
losses = []
for i in range(epochs):
    y_pred = mlp.forward(X_train)
    loss = criterion(y_pred, y_train)
    losses.append(loss.item())
    
    if (i+1) % 10 == 0:
        print(f'Epoch: {i+1} and loss: {loss}')

    optimizer.zero_grad()
    loss.backward()
    optimizer.step()
```

Plot training error.

```{python}
plt.plot(range(epochs), losses)
plt.ylabel("loss/error")
plt.xlabel('Epoch')
```

```{python}
with torch.no_grad():
    y_eval = mlp.forward(X_test)
    loss = criterion(y_eval, y_test)

loss
```

```{python}
correct = 0
with torch.no_grad():
    for i, data in enumerate(X_test):
        y_val = mlp.forward(data)

        print(f'{i+1}.)  {str(y_val)} \t {y_test[i]} \t {y_val.argmax().item()}')
```